load 'basicgenerator.rb'

# Here we generate the C++ code that will in turn create the typemaps
# for HPX Serialization.
class HPXGenerator
  include BasicGenerator

  def initialize(template_path="./", namespace=nil, macro_guard_hpx=nil)
    init_generator(template_path, namespace)
    @macro_guard_hpx = macro_guard_hpx
  end

  # Creating a serialize() function for HPX is much simpler than
  # creating one for MPI as we only need a list of the class' member
  # names and parent types.
  def generate_hpx_serialize_function(klass, members, parents, template_parameters)
    params1 = render_template_params1(template_parameters)
    params2 = render_template_params2(template_parameters)

    ret = <<EOF
    template<typename ARCHIVE#{params1}>
    inline
    static void serialize(ARCHIVE& archive, #{klass}#{params2}& object, const unsigned /*version*/)
    {
EOF

    parents.sort.each do |parent_type|
      ret += <<EOF
        archive & hpx::serialization::base_object<#{parent_type} >(object);
EOF
    end

    members.keys.sort.each do |member|
      ret += <<EOF
        archive & object.#{member};
EOF
    end

    ret += <<EOF
    }
EOF

    return ret
  end

  # By default HPX Serialization will look in its own namespace for
  # suitable serialization functions. Those are defined here.
  def generate_hpx_namespace_link(klass, template_parameters)
    params1 = render_template_params1(template_parameters)
    params2 = render_template_params2(template_parameters)

    return <<EOF
template<class ARCHIVE#{params1}>
void serialize(ARCHIVE& archive, #{klass}#{params2}& object, const unsigned version)
{
    Serialization::serialize(archive, object, version);
}
EOF
  end

  def render_template_params1(template_parameters)
    params = ""
    template_parameters.each do |parameter|
      params += ", #{parameter[:type]} #{parameter[:name]}"
    end

    return params
  end

  def render_template_params2(template_parameters)
    params = template_parameters.map { |parameter| parameter[:name] }
    params = params.join(", ")
    if (params.size > 0)
      params = "<#{params}>"
    end
  end

  # the header generated by this function only contains the serialize() functions for HPX Serialize
  def generate_header(classes, resolved_classes, resolved_parents, template_parameters, headers, header_pattern=nil, header_replacement=nil)
    ret = File.read(@path + "template_serialization_hpx.h");
    ret.gsub!(/HEADERS/, map_headers(headers, header_pattern, header_replacement))
    ret.gsub!(/NAMESPACE_GUARD/, @namespace_guard)
    ret.gsub!(/NAMESPACE_BEGIN\n/, @namespace_begin)
    ret.gsub!(/NAMESPACE_END\n/, @namespace_end)

    serializations = classes.map do |klass|
      generate_hpx_serialize_function(klass, resolved_classes[klass], resolved_parents[klass], template_parameters[klass])
    end
    ret.sub!(/.*HPX_SERIALIZATIION_DEFINITIONS/, serializations.join("\n"))

    serializations = classes.map do |klass|
      generate_hpx_namespace_link(klass, template_parameters[klass])
    end

    namespace = ""
    if !@namespace.nil?
      namespace = <<EOF
using namespace #{@namespace};
EOF
    end

    ret.sub!(/.*HPX_NAMESPACE_LINK/, ([ namespace ] + serializations).join("\n"))

    return guard(@macro_guard_hpx, ret)
  end

  # wraps the code generation for multiple typemaps.
  def generate_forest(resolved_classes, resolved_parents, template_parameters, class_sortation, headers, header_pattern=nil, header_replacement=nil)
    return [generate_header(class_sortation, resolved_classes, resolved_parents, template_parameters, headers, header_pattern, header_replacement)]
  end
end
