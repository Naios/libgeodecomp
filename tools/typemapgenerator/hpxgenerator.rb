load 'basicgenerator.rb'

# Here we generate the C++ code that will in turn create the typemaps
# for HPX Serialization.
class HPXGenerator
  include BasicGenerator

  def initialize(template_path="./", namespace=nil, macro_guard_hpx=nil)
    init_generator(template_path, namespace)
    @macro_guard_hpx = macro_guard_hpx
  end

  def base_object_name
    "hpx::serialization::base_object"
  end

  # By default HPX Serialization will look in its own namespace for
  # suitable serialization functions. Those are defined here.
  def generate_hpx_namespace_link(klass, template_parameters)
    params1 = render_template_params1(template_parameters)
    params2 = render_template_params2(template_parameters)

    return <<EOF
template<class ARCHIVE#{params1}>
void serialize(ARCHIVE& archive, #{klass}#{params2}& object, const unsigned version)
{
    Serialization::serialize(archive, object, version);
}
EOF
  end

  # the header generated by this function only contains the serialize() functions for HPX Serialize
  def generate_header(classes, resolved_classes, resolved_parents, template_parameters, headers, header_pattern=nil, header_replacement=nil)
    ret = File.read(@path + "template_serialization.h");
    ret.gsub!(/HEADERS/, map_headers(headers, header_pattern, header_replacement))
    ret.gsub!(/NAMESPACE_GUARD/, @namespace_guard)
    ret.gsub!(/NAMESPACE_BEGIN\n/, @namespace_begin)
    ret.gsub!(/NAMESPACE_END\n/, @namespace_end)

    serializations = classes.map do |klass|
      generate_serialize_function(klass, resolved_classes[klass], resolved_parents[klass], template_parameters[klass])
    end
    ret.sub!(/.*SERIALIZATIION_DEFINITIONS/, serializations.join("\n"))

    serializations = classes.map do |klass|
      generate_hpx_namespace_link(klass, template_parameters[klass])
    end

    namespace = ""
    if !@namespace.nil?
      namespace = <<EOF
using namespace #{@namespace};
EOF
    end

    ret.sub!(/.*NAMESPACE_LINK/, ([ namespace ] + serializations).join("\n"))

    return guard(@macro_guard_hpx, ret)
  end

  # wraps the code generation for multiple typemaps.
  def generate_forest(resolved_classes, resolved_parents, template_parameters, class_sortation, headers, header_pattern=nil, header_replacement=nil)
    return [generate_header(class_sortation, resolved_classes, resolved_parents, template_parameters, headers, header_pattern, header_replacement)]
  end
end
