#include <libgeodecomp.h>

using namespace LibGeoDecomp;

class CactusCell
{
public:
    class API :
        public APITraits::HasFixedCoordsOnlyUpdate,
        public APITraits::HasSoA,
        public APITraits::HasTorusTopology<3>,
        public APITraits::HasStencil<Stencils::Moore<3, 1> >,
        public APITraits::HasUpdateLineX
    {};

    // roughly imitating what's required by WaveToyC_Evolution in
    // "Cactus/arrangements/CactusWave/WaveToyC/src/WaveToy.c".
    template<typename ACCESSOR1, typename ACCESSOR2>
    static void updateLineX(ACCESSOR1 hoodOld, int *indexOld, int indexEnd, ACCESSOR2 hoodNew, int *indexNew, unsigned nanoStep)
    {
        // manually generated interface code starts here. will be auto-generated by Kurt's scripts lateron.
#define DECLARE_CCTK_ARGUMENTS
#define CCTK_REAL double
#define CCTK_DELTA_SPACE(DIM) 0.1
#define CCTK_DELTA_TIME 0.1
#define CCTK_GFINDEX3D(CCTKGH, I, J, K) (I - 1)

#define phi          (&hoodNew.var_phi())
#define phi_next_p_p (&hoodNew.var_phi_p())
#define phi_p        (&hoodOld[FixedCoord<0, 0, 0>()].var_phi())
#define phi_p_p      (&hoodOld[FixedCoord<0, 0, 0>()].var_phi_p())

        // carefully set fake indices so that the offsets set below
        // are equalized (together with our definition of CCTK_GFINDEX3D()
        int cctk_lsh[] = {indexEnd - *indexOld + 2, 2, 2};

        // REMARK: verbatim code copy (only whitespace changes) from
        // WaveToyC_Evolution(), starting here...
        DECLARE_CCTK_ARGUMENTS;

        int i,j,k;
        int vindex;
        int istart, jstart, kstart, iend, jend, kend;
        CCTK_REAL dx,dy,dz,dt,dx2,dy2,dz2,dt2;
        CCTK_REAL dx2i,dy2i,dz2i;

        CCTK_REAL factor;

        /* Set up shorthands */
        dx = CCTK_DELTA_SPACE(0);
        dy = CCTK_DELTA_SPACE(1);
        dz = CCTK_DELTA_SPACE(2);
        dt = CCTK_DELTA_TIME;

        dx2 = dx*dx;
        dy2 = dy*dy;
        dz2 = dz*dz;
        dt2 = dt*dt;

        dx2i = 1.0/dx2;
        dy2i = 1.0/dy2;
        dz2i = 1.0/dz2;

        istart = 1;
        jstart = 1;
        kstart = 1;

        iend = cctk_lsh[0]-1;
        jend = cctk_lsh[1]-1;
        kend = cctk_lsh[2]-1;

        /* Do the evolution */
        factor = 2*(1 - (dt2)*(dx2i + dy2i + dz2i));

        for (k=kstart; k<kend; k++) {
            for (j=jstart; j<jend; j++) {
                for (i=istart; i<iend; i++) {
                    vindex = CCTK_GFINDEX3D(cctkGH,i,j,k);

                    phi[vindex] = factor*
                        phi_p[vindex] - phi_p_p[vindex]
                        + (dt2) *
                        ( ( phi_p[CCTK_GFINDEX3D(cctkGH,i+1,j  ,k  )]
                            +phi_p[CCTK_GFINDEX3D(cctkGH,i-1,j  ,k  )] )*dx2i
                          +( phi_p[CCTK_GFINDEX3D(cctkGH,i  ,j+1,k  )]
                             +phi_p[CCTK_GFINDEX3D(cctkGH,i  ,j-1,k  )] )*dy2i
                          +( phi_p[CCTK_GFINDEX3D(cctkGH,i  ,j  ,k+1)]
                             +phi_p[CCTK_GFINDEX3D(cctkGH,i  ,j,  k-1)] )*dz2i);
                }
            }
        }
        // REMARK: ...and ending here.

        // copy over old member, should be auto-generated
        for (i=istart; i<iend; i++) {
            vindex = CCTK_GFINDEX3D(cctkGH, i, 0, 0);
            phi_next_p_p[vindex] = phi_p[vindex];
        }
    }

    double var_phi;
    double var_phi_p;
};

LIBFLATARRAY_REGISTER_SOA(CactusCell, ((double)(var_phi))((double)(var_phi_p)))

class CactusInitializer : public SimpleInitializer<CactusCell>
{
public:
    CactusInitializer(const Coord<3> gridDim, unsigned maxSteps) :
        SimpleInitializer<CactusCell>(gridDim, maxSteps)
    {}

    virtual void grid(GridBase<CactusCell, 3> *target)
    {
    }

};

int main(int argc, char **argv)
{
    Coord<3> gridDim(30, 30, 30);
    int maxSteps = 500;
    int outputPeriod = 100;

    SerialSimulator<CactusCell> sim(new CactusInitializer(gridDim, maxSteps));
    sim.addWriter(new TracingWriter<CactusCell>(outputPeriod, maxSteps));
    sim.run();
}
